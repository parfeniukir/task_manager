# Пояснення коду

1. TaskListView: Відображає список завдань, що належать поточному користувачу.
2. TaskCreateView: Дозволяє створювати нові завдання, автоматично встановлюючи власника як поточного користувача.
3. TaskToggleCompleteView: Перемикає стан виконання завдання (завершено/не завершено) для завдання, що належить поточному користувачу.
4. TaskUpdateView: Дозволяє редагувати завдання, якщо воно належить поточному користувачу.
5. TaskDeleteView: Дозволяє видаляти завдання, якщо воно належить поточному користувачу.

- **LoginRequiredMixin** - Mixin, який **не пускає неавторизованих користувачів** у view.
  Якщо користувач не залогінений - Django робить redirect на сторінку логіну
- **context_object_name** - Імʼя змінної, під яким дані з view **передаються в шаблон**.
  Без цього Django передав би змінну як `task_list`
- **get_queryset** - Метод, який визначає **які обʼєкти брати з бази**.
  **Навіщо?** щоб користувач бачив **тільки свої задачі** та не бачив чужі
- **success_url** - URL, куди перенаправити користувача після успішної дії.
  У нашому випадку, після створення задачі - повертаємось до списку задач.
- **reverse_lazy** - Функція, яка **перетворює імʼя URL у реальний шлях**, але **не одразу**, а пізніше.
  **Чому не reverse:** Class-Based Views завантажуються до того, як Django повністю знає всі URL-и.
  Просте правило для студентів:
   - function-based view - можна reverse
   - class-based view - reverse_lazy

- **form_valid** - Метод, який викликається, **коли форма пройшла валідацію**.
  **Навіщо:**
  Поле owner
   - не вводиться користувачем
   - але обовʼязкове
	**Логіка:**
	- Форма валідна
	- Ми доповнюємо обʼєкт
	- Зберігаємо його


## TaskToggleCompleteView

### 1 Навіщо тут `View`

`View` - це базовий клас для Class-Based Views.
Він дає вам структуру, де ви можете описати методи для HTTP-дій:

1. `get()` - для GET-запиту
2. `post()` - для POST-запиту
3. і т.д.

У нас дія “позначити як виконане” - це зміна даних, тому використовуємо **POST**, а значить реалізуємо `post()`.

### 2 Навіщо `LoginRequiredMixin`

Цей mixin робить одне:

- якщо користувач **не залогінений**, він не може виконати дію
- Django автоматично зробить redirect на сторінку логіну

Тобто без логіну не можна “тикати галочку” і змінювати задачі.

### 3 Навіщо `UserPassesTestMixin`

Цей mixin викликає ваш метод `test_func()` і вирішує:

1. Якщо `test_func()` повернув `True` - дозволити запит
2. Якщо `False` - заблокувати (403 Forbidden)

Це і є **перевірка прав доступу**.

### 4 `test_func` - як працює і що тут відбувається

```python
def test_func(self):
    task = Task.objects.filter(pk=self.kwargs["pk"]).first()
    return task is not None and task.owner == self.request.user

```

#### 4.1. Звідки береться `self.kwargs["pk"]`

У вас в urls є маршрут типу:

`/tasks/<int:pk>/toggle/`

Тому Django витягує число з URL і кладе його в `kwargs`, наприклад:
- користувач відкрив `/tasks/5/toggle/`
- тоді `kwargs["pk"] == 5`

У CBV це доступно як:
- `self.kwargs["pk"]`

#### 4.2. Чому `.filter(...).first()`, а не `.get(...)`

`filter(...).first()`:
- якщо задачі немає - поверне `None` (без помилки)

Це зручно в `test_func`, бо ми можемо спокійно перевірити:
1. чи існує задача
2. чи вона належить користувачу

#### 4.3. Що повертає `test_func`

Повертає boolean:
- `True`, якщо задача існує і `task.owner == request.user`
- `False`, якщо задачі немає або вона чужа

Фраза:
`task is not None and task.owner == self.request.user`
означає:
- “завдання має існувати”
    і
- “власник має бути поточний користувач”


### 5 `post` - що відбувається при кліку на checkbox

```python
def post(self, request, *args, **kwargs):
    task = Task.objects.get(pk=kwargs["pk"], owner=request.user)
    task.is_completed = not task.is_completed
    task.save(update_fields=["is_completed"])
    return redirect("task-list")
```

#### 5.1. Коли викликається `post`

У `task_list.html` checkbox має:
- `onchange="this.form.submit()"`

Тобто:
1. ви клацаєте чекбокс
2. форма автоматично відправляє POST на `/tasks/<pk>/toggle/`
3. Django потрапляє у `TaskToggleCompleteView.post()`

#### 5.2. Навіщо `Task.objects.get(pk=..., owner=request.user)`

Це повторна “страховка” на рівні запиту до БД.

Ми явно кажемо:
- знайди задачу з таким `pk`
- але тільки якщо `owner` - поточний користувач

Якщо хтось спробує підставити чужий `pk`, то:

- `.get(...)` не знайде таку задачу для цього користувача
- і Django видасть помилку “обʼєкт не знайдено” (404)

Тобто навіть якщо `test_func` з якоїсь причини змінять, тут все одно є захист.

#### 5.3. Що робить `task.is_completed = not task.is_completed`

Це перемикання стану:

- було `False` - стане `True`
- було `True` - стане `False`

Тому це “toggle”.

#### 5.4. Навіщо `update_fields=["is_completed"]`

Це оптимізація і хороша практика.

Вона каже Django:
- при збереженні онови **тільки** поле `is_completed`
- не чіпай інші поля

#### 5.5. `redirect("task-list")`

Після POST-запиту ми робимо redirect на сторінку списку задач.

Це класичний патерн:
- POST -> redirect -> GET

Щоб:
- при оновленні сторінки браузер не пересилав POST ще раз
- і щоб користувач бачив актуальний список

### Підсумуємл

1. Це не CRUD сторінка, а “дія” над обʼєктом (toggle)
2. Зміна даних - тільки через POST
3. Перевірки доступу мають бути на бекенді
4. `kwargs["pk"]` - це параметр з URL
5. Після POST ми робимо redirect
